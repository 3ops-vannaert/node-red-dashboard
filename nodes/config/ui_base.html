<style>
    #ff-node-red-dashboard {
        --ff-grey-100: #F3F4F6;
    }
    #ff-node-red-dashboard .red-ui-sidebar-header {
        display: flex;
        justify-content: space-between;
    }
    #ff-node-red-dashboard .red-ui-sidebar-header label {
        margin-bottom: 0;
    }
    #ff-node-red-dashboard .red-ui-editableList-container {
        padding: 0;
    }
    /* Dashboard 2.0 Sidebar */
    .nrdb2-layout-order-editor {
        padding: 8px 10px;
    }
    .nrdb2-layout-order-editor--pages {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 9px;
    }
    .nrdb2-sb-pages-list li {
        padding: 0;
        border-bottom: 0;
    }
    .nrdb2-sb-list-header {
        display: flex;
        gap: 6px;
        align-items: center;
        padding: 9px 6px;
        cursor: pointer;
    }
    .nrdb2-sb-list-handle {
        opacity: 0;
        transition: 0.15s opacity;
    }
    .nrdb2-sb-list-header:hover {
        background-color: var(--ff-grey-100);
    }
    .nrdb2-sb-list-header:hover .nrdb2-sb-list-handle {
        opacity: 1;
    }
</style>


<script type="text/javascript">
(function () {
    const sidebarContentTemplate = '<div id="ff-node-red-dashboard"></div>'

    // convert to i18 text
    function c_ (x) {
        return RED._('@flowforge/node-red-dashboard/ui-base:ui-base.' + x)
    }

    function hasProperty (obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop)
    }

    RED.nodes.registerType('ui-base', {
        category: 'config',
        defaults: {
            name: {
                value: 'UI Name',
                required: true
            },
            path: {
                value: '/dashboard',
                required: true
            }
        },
        label: function () {
            return `${this.name} [${this.path}]` || 'UI Config'
        }
    })

    /**
     * Add Custom Dashboard Side Menu
     * */

    const sidebar = $(sidebarContentTemplate)

    function uiLink (name, path) {
        return `<div class="red-ui-sidebar-header"><label>${name}</label><a id="open-dashboard" href="${path}" target="nr-dashboard" class="editor-button editor-button-small nrdb2-sb-list-header-button">Open Dashboard<i style="margin-left: 3px;" class="fa fa-external-link"></i></a></div>`
    }

    /**
     * Add an editor to control the ordering of groups & widgets
     */

    function buildLayoutOrderEditor () {
        // layout/order editor
        const divTabs = $('<div>', { class: 'nrdb2-layout-order-editor' }).appendTo(sidebar)

        // section header - Pages
        const pagesHeader = $('<div>', { class: 'nrdb2-layout-order-editor--pages' }).appendTo(divTabs)
        $('<b>').html(c_('layout.pages')).appendTo(pagesHeader)

        // toggle "all" buttons
        const buttonGroup = $('<div>', { class: 'nrdb2-sb-list-button-group' }).appendTo(pagesHeader)

        // Toggle expand buttons
        $('<a href="#" class="editor-button editor-button-small nrdb2-sb-list-header-button"><i class="fa fa-angle-double-up"></i></a>')
            .click(function (evt) {
                evt.preventDefault()
            })
            .appendTo(buttonGroup)

        $('<a href="#" class="editor-button editor-button-small nrdb2-sb-list-header-button"><i class="fa fa-angle-double-down"></i></a>')
            .click(function (evt) {
                evt.preventDefault()
            })
            .appendTo(buttonGroup)

        // get all pages & all groups
        const pages = {}
        const groupsByPage = {}
        RED.nodes.eachConfig(function (n) {
            if (n.type === 'ui-page' && !!n.ui) {
                pages[n.id] = n
            }
            if (n.type === 'ui-group' && !!n.page) {
                if (!groupsByPage[n.page]) {
                    groupsByPage[n.page] = []
                }
                groupsByPage[n.page].push(n)
            }
        })
        console.log(pages, groupsByPage)

        const pagesOL = $('<ol>', { class: 'nrdb2-sb-pages-list' }).appendTo(divTabs).editableList({
            sortable: '.nrdb2-sb-pages-list-header',
            addButton: false,
            addItem: function (container, i, page) {
                container.addClass('nrdb2-sb-pages-list-item')

                const titleRow = $('<div>', { class: 'nrdb2-sb-list-header nrdb2-sb-pages-list-header' }).appendTo(container)
                $('<i class="nrdb2-sb-list-handle nrdb2-sb-page-list-handle fa fa-bars"></i>').appendTo(titleRow)
                $('<i class="fa fa-angle-down nrdb2-sb-list-chevron">', { style: 'width:10px;' }).appendTo(titleRow)
                const tabicon = 'fa-object-group'
                $('<i>', { class: 'nrdb2-sb-icon nrdb2-sb-tab-icon fa ' + tabicon }).appendTo(titleRow)
                $('<span>', { class: 'nrdb2-sb-title' }).text(page.name || page.id).appendTo(titleRow)
            },
            sortItems: function (items) {
                console.log(items)
                // track any changes
                const events = []
                items.each((i, el) => {
                    const page = el.data('data')
                    // const pageNode = RED.nodes.node(page.id)
                    // console.log(pageNode)
                    if (page.order !== i) {
                        // update the order property for exposure to UI
                        page.order = i
                        // update Node-RED node properties to trigger a redeploy
                        page.dirty = true
                        page.changed = true
                    }
                    const hev = {
                        t: 'edit',
                        node: page,
                        changes: {
                            order: page.order
                        },
                        dirty: page.dirty,
                        changed: page.changed
                    }
                    events.push(hev)
                })

                // add our changes to NR history and trigger whether or not we need to redeploy
                RED.history.push({
                    t: 'multi',
                    events
                })
                RED.nodes.dirty(true)
                RED.view.redraw()
            }
        })

        // ordered list for pages to manage group ordering
        const groupsOL = $('<ol>', { class: 'nrdb2-sb-group-list' }).appendTo(sidebar).editableList({
            sortable: '.nrdb2-sb-group-list-header',
            addButton: false,
            height: 'auto',
            connectWith: '.nrdb2-sb-group-list',
            addItem: function (container, i, group) {
                // if (!group.node) {
                //     group.node = {
                //         id: RED.nodes.id(),
                //         _def: RED.nodes.getType('ui_group'),
                //         type: 'ui_group',
                //         users: [],
                //         tab: item.node.id,
                //         order: i + 1,
                //         name: 'Group ' + (i + 1),
                //         width: 6,
                //         disp: true
                //     }
                //     listElements[group.node.id] = container
                //     RED.nodes.add(group.node)
                //     RED.editor.validateNode(group.node)
                //     group.widgets = []
                //     RED.history.push({
                //         t: 'add',
                //         nodes: [group.node.id],
                //         dirty: RED.nodes.dirty()
                //     })
                //     RED.nodes.dirty(true)
                //     if (RED.nodes.hasOwnProperty('updateConfigNodeUsers')) {
                //         RED.nodes.updateConfigNodeUsers(group.node)
                //     }
                // } else {
                //     if (group.node.order === undefined) {
                //         group.node.order = i + 1
                //     }
                // }
                console.log(container, i)
                console.log(group)
                const groupNode = group.node
                // elementParents[groupNode] = item.node.id
                const titleRow = $('<div>', { class: 'nrdb2-sb-list-header nrdb2-sb-group-list-header' }).appendTo(container)
                $('<i class="nrdb2-sb-list-handle nrdb2-sb-group-list-handle fa fa-bars"></i>').appendTo(titleRow)
                $('<i class="fa fa-angle-down nrdb2-sb-list-chevron">', { style: 'width:10px;' }).appendTo(titleRow)
                $('<i class="nrdb2-sb-icon nrdb2-sb-group-icon fa fa-table"></i>').appendTo(titleRow)
                $('<span class="nrdb2-sb-title">').text(groupNode.name || groupNode.id || '').appendTo(titleRow)
                // listElements[groupNode.id] = container
                // const buttonGroup = $('<div>', { class: 'nrdb2-sb-list-header-button-group', id: groupNode.id }).appendTo(titleRow)
                // const spacerButton = $('<a href="#" class="editor-button editor-button-small nrdb2-sb-list-header-button"><i class="fa fa-plus"></i> ' + c_('layout.spacer') + '</a>').appendTo(buttonGroup)
                // spacerButton.on('click', function (evt) {
                //     if (isLocked(item.node.id)) {
                //         evt.stopPropagation()
                //         evt.preventDefault()
                //         notifyLocked()
                //         return
                //     }
                //     const spaceNode = {
                //         _def: RED.nodes.getType('ui_spacer'),
                //         type: 'ui_spacer',
                //         hasUsers: false,
                //         users: [],
                //         id: RED.nodes.id(),
                //         tab: item.node.name,
                //         group: group.node.id,
                //         order: i + 1,
                //         name: 'spacer',
                //         width: 1,
                //         height: 1,
                //         z: RED.workspaces.active(),
                //         label: function () { return 'spacer ' + this.width + 'x' + this.height }
                //     }
                //     RED.nodes.add(spaceNode)
                //     RED.editor.validateNode(spaceNode)
                //     RED.history.push({
                //         t: 'add',
                //         nodes: [spaceNode.id],
                //         dirty: RED.nodes.dirty()
                //     })
                //     RED.nodes.dirty(true)
                //     RED.view.redraw()
                //     evt.stopPropagation()
                //     evt.preventDefault()
                // })
                // const editButton = $('<a href="#" class="nrdb2-sb-edit-group-button editor-button editor-button-small nrdb2-sb-list-header-button"><i class="fa fa-pencil"></i> ' + c_('layout.edit') + '</a>').appendTo(buttonGroup)
                // const content = $('<div>', { class: 'nrdb2-sb-widget-list-container' }).appendTo(container)
                // if (!listStates.hasOwnProperty(groupNode.id) || !listStates[groupNode.id]) {
                //     content.hide()
                //     chevron.css({ transform: 'rotate(-90deg)' })
                //     content.addClass('nrdb2-sb-collapsed')
                //     listStates[groupNode.id] = false
                // } else {
                //     listStates[groupNode.id] = true
                // }

                // var ol = $('<ol>', { class: 'nrdb2-sb-widget-list' }).appendTo(content).editableList({
                //     sortable: '.nrdb2-sb-widget-list-header',
                //     addButton: false,
                //     height: 'auto',
                //     connectWith: '.nrdb2-sb-widget-list',
                //     addItem: function (container, i, widgetNode) {
                //         elementParents[widgetNode.id] = groupNode.id
                //         const titleRow = $('<div>', { class: 'nrdb2-sb-list-header nrdb2-sb-widget-list-header' }).appendTo(container)
                //         $('<i class="nrdb2-sb-list-handle nrdb2-sb-widget-list-handle fa fa-bars"></i>').appendTo(titleRow)
                //         $('<i class="nrdb2-sb-icon nrdb2-sb-widget-icon fa fa-picture-o"></i>').click(function (e) { e.preventDefault(); RED.search.show(widgetNode.id) }).appendTo(titleRow)
                //         let l = widgetNode._def.label
                //         try {
                //             l = (typeof l === 'function' ? l.call(widgetNode) : l) || ''
                //         } catch (err) {
                //             console.log('Definition error: ' + d.type + '.label', err)
                //             l = d.type
                //         }
                //         const title = $('<span class="nrdb2-sb-title">').text(l).appendTo(titleRow)
                //         listElements[widgetNode.id] = container
                //         const buttonGroup = $('<div>', { class: 'nrdb2-sb-list-header-button-group' }).appendTo(titleRow)
                //         const editButton = $('<a href="#" class="editor-button editor-button-small nrdb2-sb-list-header-button"><i class="fa fa-pencil"></i> ' + c_('layout.edit') + '</a>').appendTo(buttonGroup)
                //         container.on('mouseover', function () {
                //             widgetNode.highlighted = true
                //             widgetNode.dirty = true
                //             RED.view.redraw()
                //         })
                //         container.on('mouseout', function () {
                //             widgetNode.highlighted = false
                //             widgetNode.dirty = true
                //             RED.view.redraw()
                //         })
                //         editButton.on('click', function (evt) {
                //             if (isLockedTab(widgetNode.z)) {
                //                 evt.stopPropagation()
                //                 evt.preventDefault()
                //                 notifyLocked()
                //                 return
                //             }
                //             RED.editor.edit(widgetNode)
                //             evt.stopPropagation()
                //             evt.preventDefault()
                //         })
                //     },
                //     sortItems: function (items) {
                //         if (isLocked(item.node.id)) {
                //             $(ol).editableList('cancel')
                //             notifyLocked()
                //             return
                //         }
                //         const historyEvents = []
                //         items.each(function (i, el) {
                //             const node = el.data('data')
                //             const hev = {
                //                 t: 'edit',
                //                 node,
                //                 changes: {
                //                     order: node.order,
                //                     group: node.group
                //                 },
                //                 dirty: node.dirty,
                //                 changed: node.changed
                //             }
                //             historyEvents.push(hev)
                //             let changed = false
                //             if (node.order !== i + 1) {
                //                 node.order = i + 1
                //                 changed = true
                //             }
                //             if (node.group !== group.node.id) {
                //                 const oldGroupNode = RED.nodes.node(node.group)
                //                 if (oldGroupNode) {
                //                     const index = oldGroupNode.users.indexOf(node)
                //                     oldGroupNode.users.splice(index, 1)
                //                 }
                //                 node.group = group.node.id
                //                 group.node.users.push(node)
                //                 changed = true
                //             }
                //             if (changed) {
                //                 node.dirty = true
                //                 node.changed = true
                //             }
                //         })
                //         RED.history.push({
                //             t: 'multi',
                //             events: historyEvents
                //         })
                //         RED.nodes.dirty(true)
                //         RED.view.redraw()
                //     }
                // })
                // ol.css('min-height', '5px')
                // if (groupNode.id) {
                //     groupLists[groupNode.id] = ol
                // }
                // titleRow.click(titleToggle(groupNode.id, content, chevron))
                // editButton.on('click', function (evt) {
                //     if (isLocked(item.node.id)) {
                //         evt.stopPropagation()
                //         evt.preventDefault()
                //         notifyLocked()
                //         return
                //     }
                //     RED.editor.editConfig('', groupNode.type, groupNode.id)
                //     evt.stopPropagation()
                //     evt.preventDefault()
                // })
                // group.widgets.forEach(function (widget) {
                //     ol.editableList('addItem', widget)
                // })
            },
            sortItems: function (items) {
                // called everytime an item is moved in the list

                // const historyEvents = []
                // items.each(function (i, el) {
                //     const groupData = el.data('data')
                //     const node = groupData.node
                //     const hev = {
                //         t: 'edit',
                //         node,
                //         changes: {
                //             order: node.order,
                //             tab: node.tab
                //         },
                //         dirty: node.dirty,
                //         changed: node.changed
                //     }
                //     historyEvents.push(hev)
                //     let changed = false
                //     if (node.order !== i + 1) {
                //         node.order = i + 1
                //         changed = true
                //     }
                //     if (changed) {
                //         node.dirty = true
                //         node.changed = true
                //     }
                //     if (node.tab !== item.node.id) {
                //         const oldTabNode = RED.nodes.node(node.tab)
                //         if (oldTabNode) {
                //             const index = oldTabNode.users.indexOf(node)
                //             oldTabNode.users.splice(index, 1)
                //         }
                //         node.tab = item.node.id
                //         item.node.users.push(node)
                //         changed = true
                //     }
                // })
                // RED.history.push({
                //     t: 'multi',
                //     events: historyEvents
                // })
                // RED.nodes.dirty(true)
                // RED.view.redraw()
            }
        })
        Object.values(groupsByPage).sort((a, b) => a.order - b.order).forEach(function (groups) {
            console.log(groups)
            const page = pages[groups[0].page]
            if (page) {
                pagesOL.editableList('addItem', page)
            }
            // groups.forEach(() => {

            // })
        })
    }

    RED.sidebar.addTab({
        id: 'dashboard-2.0',
        label: 'Dashboard 2.0',
        name: 'Dashboard 2.0',
        content: sidebar,
        closeable: true,
        pinned: true,
        disableOnEdit: true,
        iconClass: 'fa fa-bar-chart',
        action: '@flowforge/node-red-dashboard:show-dashboard-2.0-tab',
        onchange: function () {
            sidebar.empty()
            RED.nodes.eachConfig(function (n) {
                if (n.type === 'ui-base') {
                    sidebar.append(uiLink(n.name, n.path))
                }
            })

            // add layout editor
            buildLayoutOrderEditor()

            // placeholder message
            sidebar.append('<span style="padding: 9px; font-style: italic; color: #a2a2a2; font-size: 8pt;">More content will be added here in future releases</span>')
        }
    })

    RED.actions.add('@flowforge/node-red-dashboard:show-dashboard-2.0-tab', function () {
        RED.sidebar.show('flowforge-nr-tools')
    })

    /**
     * jQuery widget to provide a selector for the sizing of a widget & group
     */
    $.widget('nodereddashboard.elementSizer', {
        _create: function () {
            // convert to i18 text
            function c_ (x) {
                return RED._(`@flowforge/node-red-dashboard/ui-base:ui-base.${x}`)
            }

            const thisWidget = this
            let gridWidth = 6
            const width = parseInt($(this.options.width).val() || 0)
            const height = parseInt(hasProperty(this.options, 'height') ? $(this.options.height).val() : '1') || 0
            const hasAuto = (!hasProperty(this.options, 'auto') || this.options.auto)

            this.element.css({
                minWidth: this.element.height() + 4
            })
            const autoText = c_('auto')
            const sizeLabel = (width === 0 && height === 0) ? autoText : width + (hasProperty(this.options, 'height') ? ' x ' + height : '')
            this.element.text(sizeLabel).on('mousedown', function (evt) {
                evt.stopPropagation()
                evt.preventDefault()

                const width = parseInt($(thisWidget.options.width).val() || 0)
                const height = parseInt(hasProperty(thisWidget.options, 'height') ? $(thisWidget.options.height).val() : '1') || 0
                let maxWidth = 0
                let maxHeight
                let fixedWidth = false
                const fixedHeight = false
                const group = $(thisWidget.options.group).val()
                if (group) {
                    const groupNode = RED.nodes.node(group)
                    if (groupNode) {
                        gridWidth = Math.max(6, groupNode.width, +width)
                        maxWidth = groupNode.width || gridWidth
                        fixedWidth = true
                    }
                    maxHeight = Math.max(6, +height + 1)
                } else {
                    gridWidth = Math.max(12, +width)
                    maxWidth = gridWidth
                    maxHeight = height + 1
                    // fixedHeight = false;
                }

                const pos = $(this).offset()
                const container = $('<div>').css({
                    position: 'absolute',
                    background: 'var(--red-ui-secondary-background, white)',
                    padding: '5px 10px 10px 10px',
                    border: '1px solid var(--red-ui-primary-border-color, grey)',
                    zIndex: '20',
                    borderRadius: '4px',
                    display: 'none'
                }).appendTo(document.body)

                let closeTimer
                container.on('mouseleave', function (evt) {
                    closeTimer = setTimeout(function () {
                        container.fadeOut(200, function () { $(this).remove() })
                    }, 100)
                })
                container.on('mouseenter', function () {
                    clearTimeout(closeTimer)
                })

                const label = $('<div>').css({
                    fontSize: '13px',
                    color: 'var(--red-ui-tertiary-text-color, #aaa)',
                    float: 'left',
                    paddingTop: '1px'
                }).appendTo(container).text((width === 0 && height === 0) ? autoText : (width + (hasProperty(thisWidget.options, 'height') ? ' x ' + height : '')))
                label.hover(function () {
                    $(this).css('text-decoration', 'underline')
                }, function () {
                    $(this).css('text-decoration', 'none')
                })

                label.click(function (e) {
                    const group = $(thisWidget.options.group).val()
                    let groupNode = null
                    if (group) {
                        groupNode = RED.nodes.node(group)
                        if (groupNode === null) {
                            return
                        }
                    }
                    $(thisWidget).elementSizerByNum({
                        width: thisWidget.options.width,
                        height: thisWidget.options.height,
                        groupNode,
                        pos,
                        label: thisWidget.element,
                        has_height: hasProperty(thisWidget.options, 'height')
                    })
                    closeTimer = setTimeout(function () {
                        container.fadeOut(200, function () {
                            $(this).remove()
                        })
                    }, 100)
                })

                const buttonRow = $('<div>', { style: 'text-align:right; height:25px;' }).appendTo(container)

                if (hasAuto) {
                    $('<a>', { href: '#', class: 'editor-button editor-button-small', style: 'margin-bottom:5px' })
                        .text(autoText)
                        .appendTo(buttonRow)
                        .on('mouseup', function (evt) {
                            thisWidget.element.text(autoText)
                            $(thisWidget.options.width).val(0).change()
                            $(thisWidget.options.height).val(0).change()
                            evt.preventDefault()
                            container.fadeOut(200, function () { $(this).remove() })
                        })
                }

                const cellBorder = '1px dashed var(--red-ui-secondary-border-color, lightGray)'
                const cellBorderExisting = '1px solid gray'
                const cellBorderHighlight = '1px dashed var(--red-ui-primary-border-color, black)'
                const rows = []
                const cells = []

                function addRow (i) {
                    const row = $('<div>').css({ padding: 0, margin: 0, height: '25px', 'box-sizing': 'border-box' }).appendTo(container)
                    rows.push(row)
                    cells.push([])
                    for (let j = 0; j < gridWidth; j++) {
                        addCell(i, j)
                    }
                }

                function addCell (i, j) {
                    const row = rows[i]
                    const cell = $('<div>').css({
                        display: 'inline-block',
                        width: '25px',
                        height: '25px',
                        borderRight: (j === (width - 1) && i < height) ? cellBorderExisting : cellBorder,
                        borderBottom: (i === (height - 1) && j < width) ? cellBorderExisting : cellBorder,
                        boxSizing: 'border-box',
                        cursor: 'pointer',
                        background: (j < maxWidth) ? 'var(--red-ui-secondary-background, #fff)' : 'var(--red-ui-node-background-placeholder, #eee)'
                    }).appendTo(row)
                    cells[i].push(cell)
                    if (j === 0) {
                        cell.css({ borderLeft: ((i <= height - 1) ? cellBorderExisting : cellBorder) })
                    }
                    if (i === 0) {
                        cell.css({ borderTop: ((j <= width - 1) ? cellBorderExisting : cellBorder) })
                    }
                    if (j < maxWidth) {
                        cell.data('w', j)
                        cell.data('h', i)
                        cell.on('mouseup', function () {
                            thisWidget.element.text(($(this).data('w') + 1) + (hasProperty(thisWidget.options, 'height') ? ' x ' + ($(this).data('h') + 1) : ''))
                            $(thisWidget.options.width).val($(this).data('w') + 1).change()
                            $(thisWidget.options.height).val($(this).data('h') + 1).change()
                            container.fadeOut(200, function () { $(this).remove() })
                        })
                        cell.on('mouseover', function () {
                            const w = $(this).data('w')
                            const h = $(this).data('h')
                            label.text((w + 1) + (hasProperty(thisWidget.options, 'height') ? ' x ' + (h + 1) : ''))
                            for (let y = 0; y < maxHeight; y++) {
                                for (let x = 0; x < maxWidth; x++) {
                                    cells[y][x].css({
                                        background: (y <= h && x <= w) ? 'var(--red-ui-secondary-background-selected, #ddd)' : 'var(--red-ui-secondary-background, #fff)',
                                        borderLeft: (x === 0 && y <= h) ? cellBorderHighlight : (x === 0) ? ((y <= height - 1) ? cellBorderExisting : cellBorder) : '',
                                        borderTop: (y === 0 && x <= w) ? cellBorderHighlight : (y === 0) ? ((x <= width - 1) ? cellBorderExisting : cellBorder) : '',
                                        borderRight: (x === w && y <= h) ? cellBorderHighlight : ((x === width - 1 && y <= height - 1) ? cellBorderExisting : cellBorder),
                                        borderBottom: (y === h && x <= w) ? cellBorderHighlight : ((y === height - 1 && x <= width - 1) ? cellBorderExisting : cellBorder)
                                    })
                                }
                            }
                            if (!fixedHeight && h === maxHeight - 1) {
                                addRow(maxHeight++)
                            }
                            if (!fixedWidth && w === maxWidth - 1) {
                                maxWidth++
                                gridWidth++
                                for (let r = 0; r < maxHeight; r++) {
                                    addCell(r, maxWidth - 1)
                                }
                            }
                        })
                    }
                }
                for (let i = 0; i < maxHeight; i++) {
                    addRow(i)
                }
                container.css({
                    top: (pos.top) + 'px',
                    left: (pos.left) + 'px'
                })
                container.fadeIn(200)
            })
        }
    })
})()
</script>

<script type="text/html" data-template-name="ui-base">
    <div class="form-row">
        <label for="node-config-input-name"><i class="fa fa-bookmark"></i> Name</label>
        <input type="text" id="node-config-input-name">
    </div>
    <div class="form-row">
        <label for="node-config-input-path"><i class="fa fa-bookmark"></i> Path</label>
        <input type="text" id="node-config-input-path" disabled>
        <span style="display: block; margin-left: 105px; margin-top: 0px; font-style: italic; color: #bbb; font-size: 8pt;">This option is currently disabled and still in-development.</span>
    </div>
</script>
